# Memo经济模型简版

[TOC]

# 1. Memo协议介绍

Memo协议是一个基于区块链技术的分散式存储基础设施。Memo结合了分层架构、高效的存储证明以及智能合约结算，从而构建了一个可靠、低成本且可扩展的存储服务。Memo致力于服务需要可靠数据存储的项目以及开发者，使他们可以简单地将存储基础替换为基于区块链的存储，让产品进一步去中心化。

从架构上看，Memo可以分成三个层次，分别为结算层、验证层以及存储层。

结算层将聚合所有的订单信息，并且订单金额逐步发放给存储节点，并且代币奖励机制也实现在结算层之上，而这一切都由代码驱动。

验证层中的Keeper节点将挑战Provider节点，并验证证明结果，以决定是否给Provider节点取款凭证，验证层的所有流程都将经过验证层节点的拜占庭容错共识。

存储层的分散Provider节点存储真实的数据，并定期向验证层提交存储证明，同时使用取款凭证在结算层获取一个阶段的存储收益。

# 2. 基本设计

## 2.1 代币定义

Memo是Memo协议使用的代币，用于驱动整个Memo存储协议的运转以及规模增长。

在Memo协议中，Keeper和Provider需要首先质押Memo以获得赚取收益的资格，同时用户需要支付Memo代币以存储、检索数据，为了激励数据存储，根据订单的增长，Memo会奖励分配给Keeper、Provider以及长期持币者。

Memo不仅是协议的使用代币，也是协议的权益代币，持有Memo的持币者将可以从Memo生态的增长中获益，同时参与Memo的治理。

## 2.2 设计原则

Memo代币旨在给用户以及生态参与方创造价值，提高生产力，并持续激励生态增长。Memo的经济模型将按照以下原则设计：

+ 参与方获得的激励应与其付出的成本成正比，并尽量保持公平。
+ 经济模型逻辑应尽量由代码控制，减少人为调控的部分。
+ 经济模型应鼓励参与方实施对协议有利的行为，满足激励相容。

## 2.3 代币分配

### 2.3.1 Memo经济循环

代币将在用户、开发者、Keeper以及存储节点之间循环流动，首先，用户需要购买Memo才能使用Memo的存储服务，Keeper和Provider需要先购买Memo质押才可以提供服务获取收益，而Memo的存储付费又会流动到Keeper和Provider中，同时，Keeper、Provider以及长期持币人也可以在质押池内质押Memo，从而获得Memo生态增长的激励奖励。

由此，Memo的产生是一个消费再生产的循环，并将在此过程中逐步扩大存储规模，而规模的扩大，又会提高Memo的价值。

### 2.3.2 Memo使用场景

+ Keeper和Provider首先需要在质押池内deposit一定数量的Memo才可以参与协议提供服务。
+ 用户或者开发者需要购买Memo，并将其转移至订单池内，才可以签订订单使用Memo的存储服务，同时，检索数据也需要付出一定量的Memo。
+ 由于Memo同时还代表着对整个协议的权益，所以Memo的持有人可以将Memo质押到质押池，获取奖励收益，同时，未来可能会设计治理机制，使用Memo代币可以参与到协议的治理过程。

### 2.3.3 代币创世发行分配

代币分配分为创世分配与激励奖励分配，创世代币分配份额由以下组成：

+ 投资人: 29%，将在四百天内，每天线性解锁。
+ 核心团队: 27%，由核心团队控制，一半立刻释放，另一半在400天内线性解锁。
+ 合作伙伴及顾问: 14%，一部分将锁定在订单池，其他部分线性解锁。
+ 生态基金: 29%，暂时锁定，留待以后通过治理提取使用。

## 2.4 奖励模型概述

在初始代币发行结束后，需要设计机制激励生态发展，尽快激励存储节点提供存储空间，同时激励用户存储数据。

首先，维护者（Keeper）和存储节点（Provider）需要质押Memo代币才能开始提供服务，而且任何持币人都可以在质押池质押Memo以获得奖励收益。

除质押池外，订单池记录了每个存储节点和维护节点的订单金额，在每次用户与存储节点签订订单时，用户需要提前将代币金额转移到订单池中Provider以及Keeper节点的账户，但是节点不能立刻提取资金，只能在存储周期内按时上传存储证明，慢慢取走订单池内的资金。

发送给存储节点订单池的金额，在整个存储周期由存储节点逐步领取；发送给Keeper的，一部分随着存储节点领取收益而逐步发送给Keeper，另一部分在订单到期时，直接发送给Keeper。

此外在签订订单的时候，会根据订单信息以及参数计算一个奖励量，然后将奖励的代币发送给质押池，由所有在质押池内质押代币的账户按照份额平等分配奖励。

由上可知，Memo的代币奖励将和Memo协议的使用情况绑定，当Memo协议规模扩大，才会奖励更多的Memo以满足需求。Memo的奖励将会在触发目标奖励值后减半，所以早期的生态参与方可以获得更多红利。

### 2.4.1 质押机制

Keeper和Provider在提供服务前都需要质押，质押最低限度的主代币`KeeperPledge`以及`ProviderPledge`，此外，任何持有主代币的用户都可以把自己的代币质押到质押池，以获得代币奖励奖励。

### 2.4.2 质押池分润机制

质押池为以主代币Memo为质押代币的资金池，假设在T时刻，有个人$k_1$往质押池内质押主代币Memo $x_1$个，得到$x_1$个mMemo，此时池内Memo数量$\Zeta_{Memo}= x_1$，mMemo的数量$\Zeta_{mMemo}=x_1$。

在后续的系统运行中，假设系统得到了$\Delta_x$个Memo的奖励，则$\Zeta_{Memo1}= x_1+\Delta_x, \Zeta_{mMemo1}=x_1$，则此时$x_1$个mMemo可以兑换回$(x_1+\Delta_x)$个Memo，即每个mMemo值$\frac{x_1+\Delta_x}{x_1}$个Memo。

若在B时刻，另外一人$k_2$质押了$x_2$个Memo，则此时它将获得$\frac{\Zeta_{mMemo1}}{\Zeta_{Memo1}}x_2=\frac{x_1x_2}{x_1+\Delta_x}$个mMemo，此时$\Zeta_{Memo2}=x_1+x_2+\Delta_x,\Zeta_{mMemo2}=x_1+\frac{x_2x_1}{x_1+\Delta_x}$

若此时没有奖励，则此时$k_1$可以兑换回的代币数量为$x_1 \cdot \frac{x_1+x_2+\Delta_x}{x_1+\frac{x_2x_1}{x_1+\Delta_x}}=x_1+\Delta_x$，$k_2$可以兑回的数量为$\frac{x_1x_2}{x_1+\Delta_x}\cdot\frac{x_1+x_2+\Delta_x}{x_1+\frac{x_2x_1}{x_1+\Delta_x}}=x_2$个，与其贡献等同，而一旦有新的奖励打入池子，改变了$\Zeta_{Memo1}$，那么$k_2$将兑换得比$x_2$更多的Memo。

后面的新增质押以及奖励分配与上面类似。

### 2.4.3 质押池奖励机制

奖励分配，包括长期的生态激励以及奖励奖励，以激励维护者、存储节点、用户以及代币持有者为生态做贡献，这部分分配会随着订单量的增长逐步释放。

奖励分配的上限为创世发行的一半。

奖励与存储量挂钩，并设定一些奖励目标，在每次触发订单时，会根据当前的存储状态以及订单数据，设定一个奖励量，发放到质押池，并由所有的质押者根据质押量分配。


# 3. 生态构成

## 3.1 基金会

Memo基金会主要用于生态系统建设、市场推广和社区维护等工作，同时付出部分资金用于投资促进生态发展，并保持基金会的长期可持续运行。

基金会Memo协议负有以下责任：

+ 组织开发团队或者外包任务以完成Memo协议的实现以及迭代升级。
+ 支持以及资助基于Memo开发的生态应用。
+ 长期参与Memo的社区运营，并持续贡献。

Memo基金会有权发起关于系统治理的提案，然后由社区决定该提案是否最终实施。基金会可以发起并包括但不限于以下建议:

+ 修改系统的经济参数
+ 提议对技术方案进行升级。
+ 惩罚作恶或不作为的Keeper节点。
+ 惩罚作恶或不作为的Provider节点。

## 3.2 社区生态

作为一个结合区块链的分散式去中心化存储方案，Memo协议的开发与发展离不开社区的支持。Memo基金会将积极组织和建立具有不同功能的社区，包括生态治理、开发者社区和持币人社区等，从而在多方面促进协议和生态健康稳定地发展。

## 3.3 Keeper

节点首先质押足额的保证金，然后才能在协议内成为Keeper节点。
作为Keeper节点，必须履行以下义务:

+ 股份不得少于规定金额的保证金。

+ 保证长期在线活动，并维护验证层的历史数据。

+ 检查Provider的存储证明，并通过拜占庭容错共识给Provider签发取款单。

+ 在Provider丢失数据时，调度数据修复流程。

同时，Keeper节点具有以下权益：

+ 从自己管理的订单内抽取一定比例作为收益。

+ 质押的保证金将获取协议的奖励奖励。

如果Keeper节点作恶或者不作为，则可能会遭受惩罚，即丢失保证金，并且不能再继续提供服务获取收益。

## 3.4 Provider

拥有空闲存储空间的节点可以成为Provider，首先质押足额的保证金，然后可以与用户签订订单获取收益。
作为Provider，需要履行以下义务:

+ 在质押池质押足额的保证金。

+ 按照订单规定的标准存储数据，并保证数据的可靠性和可用性。

+ 按时向验证层提交存储证明。

同时，Provider具有以下权益

+ 逐步领取用户的订单付费。
+ 从质押池中获取奖励收益。

如果Provider不履行义务，如丢失数据，不按时提交存储证明，则会遭受惩罚，扣除保证金以及转让订单。

## 3.5 开发者

开发者可以在自己的项目中使用Memo协议，更多的项目采用Memo的存储服务，会给Memo带来更多的用户和存储需求。

基金会可以通过一些开发者活动筛选对Memo协议有价值的开发者，并给予代币激励，并提供孵化服务。
开发人员需履行以下义务:

# 3. 经济模型仿真

## 3.1 参数选取

首先选取一个经济模型配置，如下所示：

```go
type TokenConfig struct {
	TotalSupply int64  // 创世代币数量，默认600_000_000 memo
	InitSupply  int64  // 初始发行量, 默认100_000_000
	LockSupply   int64 // 锁定量,默认100_000_000
	LinearSupply int64 // 线性释放量，默认100_000_000
	LockDay      int64 // 锁定释放时间，默认540天，即540天后才能使用
	LinearDay    int64 // 线性释放周期，默认180天，每天释放1/180
}

type MintConfig struct {
	RewardTarget       int64 // 奖励上限， 默认 600_000_000
	RatioInit          int64 // 奖励比例， 默认 2
	RatioDecimal       int64 
	RatioAlter         int64 // 奖励比例调整参数， 默认150；
}

type PledgeConfig struct {
	InRatio  int64   // x日年化收益超过此值，质押会增加， 默认100%
	OutRatio int64   // x日年化收益小于此值，质押会减少， 默认25%
}

type RoleConfig struct {
	KeeperPledge         int64 // keeper最小质押量， 默认1_000
	ProviderPledge       int64 // provider最小质押量， 默认1_00
	KeeperCntPerGroup    uint64 // 每个组keeper上限， 默认10
	ProviderCntPerGroup  uint64 // 每个组provider上限， 默认5000
	ProviderStorage      uint64 // provider存储上限，默认8TB，太小会导致模拟时间变长
	ProviderCreatePerDay uint64 // 每天每组添加provider上限， 默认150, 模型中每天会增加150-200 
}

type OrderConfig struct {
	DefaultSize     int64  // 订单大小，默认8GB
	DefaultDuration uint64 // 订单长度，默认365天，大于100天
	DefaultPrice    uint64 // 订单每GB价格，默认1073741824

	LinearRate int64 // 线性释放率， 默认4，即4%，支付给keeper
	EndRate    int64 // 到期释放率， 默认1，即1%，订单到期时支付给keeper
	TaxRate    int64 // 管理费，默认1，即1%
}

type SimuConfig struct {
	Duration uint64  // 模拟时间长度，默认1000天
	Detail   bool    // 是否打印中间信息
}
```

## compile and run

```
## compile
> go build
## config is stored in ~/.simu/config.toml; see result by opening localhost:10888 in web browser
> ./memo-eco 
## modify config params, run again
> ./memo-eco --config=~/.simu/config.toml
```
